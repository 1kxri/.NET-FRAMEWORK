using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using System.Xml.Linq;

namespace Course_Project.NET
{
    public partial class Form1 : Form
    {
        private string graphFolderPath;

        public Form1()
        {
            InitializeComponent();

            panel1.AutoScroll = true;
            panel1.AutoScrollMinSize = new Size(2000, 2000);

            panel1.GetType()
                .GetProperty("DoubleBuffered",
                    System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic)
                .SetValue(panel1, true, null);

            string projectFolder = Directory.GetParent(Application.StartupPath).Parent.FullName;
            graphFolderPath = Path.Combine(projectFolder, "Graph");

            textBox1.Text = "Готово.";
        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }

        // ======== Классы ========
        public class Node
        {
            public int X;
            public int Y;
            public string Name;
            public Color Color = Color.FromArgb(255, 230, 180);
        }

        public class Edge
        {
            public Node From;
            public Node To;
        }

        private List<Node> nodes = new List<Node>();
        private List<Edge> edges = new List<Edge>();

        enum Mode { None, AddNode, AddEdge, Delete }
        Mode mode = Mode.None;

        Node firstEdgeNode = null;

        const int R = 20;
        Node dragNode = null;
        bool dragging = false;

        // ======== Генератор имен ========
        string GenerateName()
        {
            int i = 1;
            while (nodes.Any(n => n.Name == "x" + i))
                i++;
            return "x" + i;
        }

        // ======== Кнопки ========
        private void button1_Click(object sender, EventArgs e)
        {
            string info =
@"ИНФОРМАЦИЯ

- Добавление вершин: нажмите 'Добавить вершины', затем кликните по панели.
- Добавление соединений: нажмите 'Добавить соединения', кликните по первой вершине, затем по второй.
- Перетаскивание: активно всегда — нажмите и держите ЛКМ на вершине, двигайте мышь.
- Удаление элемента: нажмите 'Удалить элемент', затем кликните по вершине или по ребру.
- Удалить все: очистка графа.
- Сохранить / Открыть: сохраняет и загружает XML формат.
- Топологическая сортировка: если граф ориентированный, вершины расположатся в строку в топологическом порядке. Если есть цикл — будет сообщение об ошибке.";
            MessageBox.Show(info, "Информация", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        private void button2_Click(object sender, EventArgs e)
        {
            mode = Mode.AddNode;
            textBox1.Text = "Режим: добавление вершин.";
        }

        private void button3_Click(object sender, EventArgs e)
        {
            mode = Mode.AddEdge;
            firstEdgeNode = null;
            textBox1.Text = "Режим: добавление связей.";
        }

        private void button4_Click(object sender, EventArgs e)
        {
            nodes.Clear();
            edges.Clear();
            UpdateScrollArea();
            panel1.Invalidate();
            textBox1.Text = "Полотно очищено.";
        }

        private void button5_Click(object sender, EventArgs e)
        {
            if (!Directory.Exists(graphFolderPath))
                Directory.CreateDirectory(graphFolderPath);

            SaveFileDialog dlg = new SaveFileDialog
            {
                Filter = "XML files|*.xml",
                InitialDirectory = graphFolderPath,
                FileName = "graph.xml"
            };

            if (dlg.ShowDialog() != DialogResult.OK) return;

            XDocument doc = new XDocument(
                new XElement("Graph",
                    new XElement("Nodes",
                        from node in nodes
                        select new XElement("Node",
                            new XElement("Name", node.Name),
                            new XElement("X", node.X),
                            new XElement("Y", node.Y),
                            new XElement("Color",
                                new XElement("R", node.Color.R),
                                new XElement("G", node.Color.G),
                                new XElement("B", node.Color.B)
                            )
                        )
                    ),
                    new XElement("Edges",
                        from edge in edges
                        select new XElement("Edge",
                            new XElement("From", edge.From.Name),
                            new XElement("To", edge.To.Name)
                        )
                    )
                )
            );

            doc.Save(dlg.FileName);
            textBox1.Text = "Граф сохранён в XML формате.";
        }

        private void button6_Click(object sender, EventArgs e)
        {
            if (!Directory.Exists(graphFolderPath))
                Directory.CreateDirectory(graphFolderPath);

            OpenFileDialog dlg = new OpenFileDialog
            {
                Filter = "XML files|*.xml",
                InitialDirectory = graphFolderPath
            };

            if (dlg.ShowDialog() != DialogResult.OK) return;

            try
            {
                XDocument doc = XDocument.Load(dlg.FileName);
                nodes.Clear();
                edges.Clear();

                var nodeElements = doc.Root.Element("Nodes").Elements("Node");
                foreach (var nodeElement in nodeElements)
                {
                    string name = nodeElement.Element("Name").Value;
                    int x = int.Parse(nodeElement.Element("X").Value);
                    int y = int.Parse(nodeElement.Element("Y").Value);

                    var colorElement = nodeElement.Element("Color");
                    int r = int.Parse(colorElement.Element("R").Value);
                    int g = int.Parse(colorElement.Element("G").Value);
                    int b = int.Parse(colorElement.Element("B").Value);

                    nodes.Add(new Node
                    {
                        Name = name,
                        X = x,
                        Y = y,
                        Color = Color.FromArgb(r, g, b)
                    });
                }

                var edgeElements = doc.Root.Element("Edges").Elements("Edge");
                foreach (var edgeElement in edgeElements)
                {
                    string fromName = edgeElement.Element("From").Value;
                    string toName = edgeElement.Element("To").Value;

                    Node fromNode = nodes.First(n => n.Name == fromName);
                    Node toNode = nodes.First(n => n.Name == toName);

                    edges.Add(new Edge { From = fromNode, To = toNode });
                }

                UpdateScrollArea();
                panel1.Invalidate();
                textBox1.Text = "Граф загружен из XML файла.";
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Ошибка при загрузке файла: {ex.Message}", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
                textBox1.Text = "Ошибка при загрузке графа.";
            }
        }

        private void button7_Click(object sender, EventArgs e)
        {
            var sortedNodes = TopologicalSortKahn();
            DisplayTopologicalOrder(sortedNodes);
        }

        private void button8_Click(object sender, EventArgs e)
        {
            mode = Mode.Delete;
            textBox1.Text = "Режим: удаление.";
        }

        // ======== Мышь на холсте ========
        private void panel1_MouseDown(object sender, MouseEventArgs e)
        {
            Point absolutePoint = GetAbsolutePoint(e.Location);

            Node hit = FindNode(absolutePoint);

            if (hit != null)
            {
                dragNode = hit;
                dragging = true;
            }

            if (mode == Mode.AddNode)
            {
                string nm = GenerateName();
                nodes.Add(new Node { X = absolutePoint.X, Y = absolutePoint.Y, Name = nm });
                UpdateScrollArea();
                textBox1.Text = $"Вершина {nm} добавлена.";
                panel1.Invalidate();
                return;
            }

            if (mode == Mode.AddEdge)
            {
                if (hit == null) return;

                if (firstEdgeNode == null)
                {
                    firstEdgeNode = hit;
                    textBox1.Text = $"Выбрана первая вершина: {hit.Name}";
                }
                else
                {
                    if (firstEdgeNode == hit)
                    {
                        textBox1.Text = "Нельзя соединить вершину саму с собой.";
                        firstEdgeNode = null;
                        return;
                    }

                    if (edges.Any(ed => ed.From == firstEdgeNode && ed.To == hit))
                    {
                        textBox1.Text = "Такое ребро уже существует.";
                        firstEdgeNode = null;
                        return;
                    }

                    edges.Add(new Edge { From = firstEdgeNode, To = hit });
                    UpdateScrollArea();
                    textBox1.Text = $"Создано ребро {firstEdgeNode.Name} → {hit.Name}";
                    firstEdgeNode = null;
                    panel1.Invalidate();
                }

                return;
            }

            if (mode == Mode.Delete)
            {
                if (hit != null)
                {
                    edges.RemoveAll(ed => ed.From == hit || ed.To == hit);
                    nodes.Remove(hit);
                    UpdateScrollArea();
                    textBox1.Text = $"Удалена вершина {hit.Name}";
                    panel1.Invalidate();
                    return;
                }
                else
                {
                    Edge hitEdge = edges.FirstOrDefault(ed => IsPointOnEdge(absolutePoint, ed));
                    if (hitEdge != null)
                    {
                        edges.Remove(hitEdge);
                        UpdateScrollArea();
                        textBox1.Text = $"Удалено ребро {hitEdge.From.Name} → {hitEdge.To.Name}";
                        panel1.Invalidate();
                        return;
                    }
                }
            }
        }

        private void panel1_MouseMove(object sender, MouseEventArgs e)
        {
            if (dragging && dragNode != null)
            {
                Point absolutePoint = GetAbsolutePoint(e.Location);

                dragNode.X = absolutePoint.X;
                dragNode.Y = absolutePoint.Y;
                UpdateScrollArea();
                panel1.Invalidate();
            }
        }

        private void panel1_MouseUp(object sender, MouseEventArgs e)
        {
            dragging = false;
            dragNode = null;
        }

        // ======== Вспомогательные методы для работы с координатами ========
        private Point GetAbsolutePoint(Point screenPoint)
        {
            return new Point(
                screenPoint.X + panel1.AutoScrollPosition.X,
                screenPoint.Y + panel1.AutoScrollPosition.Y
            );
        }

        private Point GetScreenPoint(Point absolutePoint)
        {
            return new Point(
                absolutePoint.X - panel1.AutoScrollPosition.X,
                absolutePoint.Y - panel1.AutoScrollPosition.Y
            );
        }

        // ======== Поиск ========
        Node FindNode(Point absolutePoint)
        {
            return nodes.FirstOrDefault(n =>
                Math.Sqrt((absolutePoint.X - n.X) * (absolutePoint.X - n.X) +
                         (absolutePoint.Y - n.Y) * (absolutePoint.Y - n.Y)) <= R);
        }

        bool IsPointOnEdge(Point absolutePoint, Edge ed)
        {
            const int tolerance = 5;
            float dx = ed.To.X - ed.From.X;
            float dy = ed.To.Y - ed.From.Y;
            float length = (float)Math.Sqrt(dx * dx + dy * dy);
            if (length < 0.001f) return false;

            float t = ((absolutePoint.X - ed.From.X) * dx + (absolutePoint.Y - ed.From.Y) * dy) / (length * length);
            t = Math.Max(0, Math.Min(1, t));

            float nearestX = ed.From.X + t * dx;
            float nearestY = ed.From.Y + t * dy;

            float dist = (float)Math.Sqrt((absolutePoint.X - nearestX) * (absolutePoint.X - nearestX) +
                                        (absolutePoint.Y - nearestY) * (absolutePoint.Y - nearestY));
            return dist <= tolerance;
        }

        // ======== Обновление области скроллинга ========
        private void UpdateScrollArea()
        {
            if (nodes.Count == 0)
            {
                panel1.AutoScrollMinSize = new Size(2000, 2000);
                return;
            }

            int minX = nodes.Min(n => n.X) - 100;
            int maxX = nodes.Max(n => n.X) + 100;
            int minY = nodes.Min(n => n.Y) - 100;
            int maxY = nodes.Max(n => n.Y) + 100;

            int requiredWidth = Math.Max(panel1.Width, maxX - minX);
            int requiredHeight = Math.Max(panel1.Height, maxY - minY);

            panel1.AutoScrollMinSize = new Size(requiredWidth, requiredHeight);
        }

        // ======== Отрисовка ========
        private void panel1_Paint(object sender, PaintEventArgs e)
        {
            Graphics g = e.Graphics;
            g.SmoothingMode = SmoothingMode.AntiAlias;

            g.TranslateTransform(panel1.AutoScrollPosition.X, panel1.AutoScrollPosition.Y);

            foreach (Edge ed in edges)
                DrawArrow(g, ed.From, ed.To);

            foreach (Node n in nodes)
            {
                g.FillEllipse(new SolidBrush(n.Color), n.X - R, n.Y - R, R * 2, R * 2);
                g.DrawEllipse(Pens.Black, n.X - R, n.Y - R, R * 2, R * 2);

                StringFormat sf = new StringFormat { Alignment = StringAlignment.Center, LineAlignment = StringAlignment.Center };
                g.DrawString(n.Name, new Font("Arial", 11, FontStyle.Bold),
                    Brushes.Black,
                    new RectangleF(n.X - R, n.Y - R, R * 2, R * 2),
                    sf);
            }
        }

        void DrawArrow(Graphics g, Node from, Node to)
        {
            float dx = to.X - from.X;
            float dy = to.Y - from.Y;
            float dist = (float)Math.Sqrt(dx * dx + dy * dy);
            if (dist < 1) return;

            float nx = dx / dist;
            float ny = dy / dist;

            float x1 = from.X + nx * R;
            float y1 = from.Y + ny * R;

            float x2 = to.X - nx * R;
            float y2 = to.Y - ny * R;

            using (Pen pen = new Pen(Color.DarkBlue, 2))
            {
                pen.CustomEndCap = new AdjustableArrowCap(8, 6, true);
                g.DrawLine(pen, x1, y1, x2, y2);
            }
        }

        // ======== Топологическая сортировка (Kahn) ========
        private List<Node> TopologicalSortKahn()
        {
            Dictionary<Node, int> indeg = nodes.ToDictionary(n => n, n => 0);

            foreach (Edge ed in edges)
                indeg[ed.To]++;

            Queue<Node> q = new Queue<Node>(indeg.Where(i => i.Value == 0).Select(i => i.Key));

            List<Node> result = new List<Node>();

            while (q.Count > 0)
            {
                Node n = q.Dequeue();
                result.Add(n);

                foreach (Edge ed in edges.Where(ed => ed.From == n))
                {
                    indeg[ed.To]--;
                    if (indeg[ed.To] == 0)
                        q.Enqueue(ed.To);
                }
            }

            if (result.Count != nodes.Count)
            {
                textBox1.Text = "Граф содержит цикл — топологическая сортировка невозможна.";
                return null;
            }

            return result;
        }

        // ======== Отображение топологического порядка ========
        private void DisplayTopologicalOrder(List<Node> sortedNodes)
        {
            if (sortedNodes == null) return;

            int startX = 80;
            int y = panel1.Height / 2;
            int step = 120;

            for (int i = 0; i < sortedNodes.Count; i++)
            {
                sortedNodes[i].X = startX + i * step;
                sortedNodes[i].Y = y;
            }

            UpdateScrollArea();
            panel1.Invalidate();
            textBox1.Text = "Топологическая сортировка выполнена.";
        }
    }
}
